'''Defines some helper functions for manipulating `File` paths.
'''

def package_relative_path(ctx, file):
    '''The `File`'s relative path within the current target's package.

    Args:
      ctx: The current target's [`ctx` object][1]. This is used to get the
        current target's package.
      file: A [`File` object][2].
    Returns:
      A string encoding the `file`'s package-relative path or `None` if `file`
      is not in the current package or one of its subpackages.

    ---

    1: https://docs.bazel.build/versions/3.4.0/skylark/lib/ctx.html
    2: https://docs.bazel.build/versions/3.4.0/skylark/lib/File.html
    '''

    # NOTE(dwtj): If I understand correctly, a file's path may have the
    #  following sequence of components from the execroot:
    #
    #  1. The root component. This is accessible via `File.root`. If
    #     `File.is_source`, then this component is the empty string. Otherwise,
    #     if the file is generated by a Bazel action, this will be non-empty.
    #     Examples that I have seen include `bazel-out/k8-fastbuild/bin/` and
    #     `bazel-out/darwin-fastbuild/bin/`. Here, the middle directory is
    #     encoding the file's configuration.
    #
    #  2. The repository component. This isn't directly accessible by any helper
    #     members of `File`. If the `File`'s package is a part of the main
    #     repository, then this is the empty string. Otherwise, this will be of
    #     the form `external/<external_repository_name>/`.
    #
    #  3. The package component. Again, this isn't directly accessible by any
    #     helper members of `File`. This is a sequence of user-defined
    #     directories corresponding to package names. (E.g., `mypkg/mysubpkg/`.)
    #     I believe that it is reasonable to assume that the first directory in
    #     this component will not be be `external/`. This let's a repository
    #     component be disambiguated from the package component.
    #
    #  4. The package-relative component. Again, this isn't directly accessible
    #     by any helper members of `File`. Like the package component, this is a
    #     sequence of user-defined names. These are subpackage/directory/file
    #     names within a Bazel package. Note that the final name in the sequence
    #     may be a directory name or a file name. `File.is_directory` can be
    #     used to distinguish between the two cases.
    #
    #  This function is designed to return this last component (or `None` if the
    #  file is not in the package of `ctx`'s `Target`).

    # NOTE(dwtj): A previous implementation of this function dropped the root
    #  component using `File.short_path`, but this is problematic when the
    #  `File` is in a package in an external repository. In this case,
    #  `File.short_path` returns a string of the following form:
    #
    #  ```
    #  ../my_external_repo/<package-component>/<package-relative-component>
    #  ```

    # NOTE(dwtj): As of 2020-09-02, there doesn't yet seem to be any official
    #  support for regular expressions in Starlark. However, there is
    #  [`qri-io/starlib`](https://github.com/qri-io/starlib), which does say it
    #  includes drop-in replacement for python's `re` module. However, I'd
    #  rather not use it: I'd be forcing a third-party external repository on my
    #  users for little benefit.

    path = file.path

    # Use a slice to drop the root component, if there is one.
    root_component = file.root.path
    if root_component != "":
        # Drop the root component and a `/`.
        path = path[len(root_component)+1:]

    if path.startswith("external/"):
        # The repository component is everything after "external/" up to and
        # including the next "/". Drop this from the path.
        idx = path.find("/", len("external/"))
        repository_component = path[:idx+1]
        path = path[idx+1:]

    target_pkg = ctx.label.package
    if target_pkg != "":
        target_pkg += "/"
    if path.startswith(target_pkg):
        pkg_component = path[:len(target_pkg)]
        pkg_relative_component = path[len(target_pkg):]
        return pkg_relative_component
    else:
        return None
